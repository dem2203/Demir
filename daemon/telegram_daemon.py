# ============================================================================
# DEMIR AI - TELEGRAM 7/24 ALERT & DAEMON SYSTEM
# ============================================================================
# Date: November 10, 2025
# Purpose: 7/24 canlÄ± piyasa takibi, saatlik Telegram bildirimleri
#
# ğŸ”’ KURALLAR:
# - ZERO MOCK DATA - GerÃ§ek API'lardan veri al
# - Async/Threading ile 24/7 Ã§alÄ±ÅŸ
# - Her saat Telegram'a status mesajÄ± gÃ¶nder
# - Sinyal oluÅŸtuÄŸunda hemen uyar
# ============================================================================

import asyncio
import threading
import logging
import os
import time
import json
from datetime import datetime, timedelta
from typing import Dict, Optional, List, Any
import requests
from queue import Queue
from enum import Enum

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - DAEMON - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('daemon.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# TELEGRAM ALERT SYSTEM (7/24 AÃ§Ä±k)
# ============================================================================

class AlertSeverity(Enum):
    \"\"\"UyarÄ± ÅŸiddeti seviyeleri\"\"\"
    INFO = 'â„¹ï¸'
    WARNING = 'âš ï¸'
    SUCCESS = 'âœ…'
    ERROR = 'âŒ'
    CRITICAL = 'ğŸš¨'
    SIGNAL = 'ğŸ“Š'

class TelegramAlertManager:
    \"\"\"
    7/24 Telegram uyarÄ± sistemi
    - GerÃ§ek zamanlÄ± sinyal bildirimleri
    - Saatlik piyasa status bildirleri
    - Hata ve uyarÄ± yÃ¶netimi
    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize Telegram alert system\"\"\"\n        self.token = os.getenv('TELEGRAM_TOKEN')\n        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')\n        self.api_url = f'https://api.telegram.org/bot{self.token}'\n        \n        self.alert_queue: Queue = Queue()\n        self.last_hourly_ping = datetime.now()\n        self.is_running = False\n        \n        if not self.token or not self.chat_id:\n            logger.error('ğŸš¨ Telegram tokens bulunamadÄ±! Bildirimleri etkinleÅŸtirmek iÃ§in:')\n            logger.error('   TELEGRAM_TOKEN ve TELEGRAM_CHAT_ID ortam deÄŸiÅŸkenlerini ayarla')\n            self.enabled = False\n        else:\n            self.enabled = True\n            logger.info('âœ… Telegram Alert System hazÄ±rlandÄ± (7/24)')\n    \n    async def send_alert(self, message: str, severity: AlertSeverity = AlertSeverity.INFO):\n        \"\"\"Telegram'a uyarÄ± gÃ¶nder (asynchronous)\"\"\"\n        if not self.enabled:\n            return False\n        \n        try:\n            # Format message\n            emoji = severity.value\n            timestamp = datetime.now().strftime('%H:%M:%S')\n            full_message = f\"{emoji} [{timestamp}]\\n{message}\"\n            \n            # Send via Telegram API\n            params = {\n                'chat_id': self.chat_id,\n                'text': full_message,\n                'parse_mode': 'HTML'\n            }\n            \n            response = requests.post(\n                f'{self.api_url}/sendMessage',\n                params=params,\n                timeout=5\n            )\n            \n            if response.status_code == 200:\n                logger.info(f'âœ… Telegram gÃ¶nderildi: {severity.name}')\n                return True\n            else:\n                logger.warning(f'âš ï¸ Telegram gÃ¶nderme hatasÄ±: {response.status_code}')\n                return False\n                \n        except Exception as e:\n            logger.error(f'âŒ Telegram hatasÄ±: {e}')\n            return False\n    \n    def queue_alert(self, message: str, severity: AlertSeverity = AlertSeverity.INFO):\n        \"\"\"UyarÄ±yÄ± kuyruÄŸa ekle (thread-safe)\"\"\"\n        self.alert_queue.put({\n            'message': message,\n            'severity': severity,\n            'timestamp': datetime.now()\n        })\n    \n    async def alert_sender_loop(self):\n        \"\"\"Async loop: kuyruktaki uyarÄ±larÄ± gÃ¶nder\"\"\"\n        logger.info('ğŸ”„ Alert Sender Loop baÅŸlatÄ±ldÄ±')\n        \n        while self.is_running:\n            try:\n                # Queue'dan mesaj al\n                while not self.alert_queue.empty():\n                    alert = self.alert_queue.get(timeout=1)\n                    await self.send_alert(\n                        alert['message'],\n                        alert['severity']\n                    )\n                    await asyncio.sleep(0.5)  # Rate limiting\n                \n                await asyncio.sleep(1)\n                \n            except Exception as e:\n                logger.error(f'Alert sender hatasÄ±: {e}')\n                await asyncio.sleep(5)\n    \n    def get_hourly_ping_message(self, market_data: Dict[str, Any]) -> str:\n        \"\"\"Saatlik status mesajÄ± oluÅŸtur\"\"\"\n        message = f\"\"\"\n<b>ğŸ¤– DEMIR AI - SAATLÄ°K DURUM BÄ°LDÄ°RÄ°MÄ°</b>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n<b>Market Status (Piyasa Durumu):</b>\nâ€¢ BTC FiyatÄ±: ${market_data.get('btc_price', 0):,.2f}\nâ€¢ 24S DeÄŸiÅŸim: {market_data.get('btc_change_24h', 0):+.2f}%\nâ€¢ ETH FiyatÄ±: ${market_data.get('eth_price', 0):,.2f}\nâ€¢ 24S DeÄŸiÅŸim: {market_data.get('eth_change_24h', 0):+.2f}%\n\n<b>Sistem Durumu (System Status):</b>\nâ€¢ Bot Durum: âœ… Ã‡ALIÅIYOR (RUNNING)\nâ€¢ API BaÄŸlantÄ±: âœ… AKTIF (CONNECTED)\nâ€¢ Son Sinyal: {market_data.get('last_signal_time', 'N/A')}\nâ€¢ Aktif Ä°ÅŸlemler: {market_data.get('active_trades', 0)}\n\n<b>Risk UyarÄ±larÄ± (Risk Alerts):</b>\nâ€¢ Volatilite: {market_data.get('volatility_status', 'Normal')}\nâ€¢ Likidite: {market_data.get('liquidity_status', 'Yeterli')}\nâ€¢ Funding Rate: {market_data.get('funding_rate', 0):+.3f}%\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nSonraki bildirim: 1 saat sonra\nZaman: {datetime.now().strftime('%H:%M:%S UTC')}\n        \"\"\"\n        return message.strip()\n\n# ============================================================================\n# MARKET DATA FETCHER (GerÃ§ek Veriler)\n# ============================================================================\n\nclass RealMarketData:\n    \"\"\"GerÃ§ek piyasa verilerini Binance'ten al\"\"\"\n    \n    def __init__(self):\n        self.base_url = 'https://fapi.binance.com'\n        self.cache = {}\n        self.cache_time = {}\n        self.cache_duration = 60  # 1 minute\n    \n    def get_ticker_24h(self, symbol: str = 'BTCUSDT') -> Dict[str, Any]:\n        \"\"\"24 saatlik ticker verisi al (Real API)\"\"\"\n        try:\n            url = f'{self.base_url}/fapi/v1/ticker/24hr'\n            response = requests.get(\n                url,\n                params={'symbol': symbol},\n                timeout=5\n            )\n            \n            if response.status_code == 200:\n                data = response.json()\n                return {\n                    'symbol': symbol,\n                    'price': float(data['lastPrice']),\n                    'change_24h': float(data['priceChangePercent']),\n                    'volume_24h': float(data['quoteAssetVolume']),\n                    'high_24h': float(data['highPrice']),\n                    'low_24h': float(data['lowPrice'])\n                }\n        except Exception as e:\n            logger.error(f'Ticker fetch hatasÄ± ({symbol}): {e}')\n        \n        return None\n    \n    def get_funding_rate(self, symbol: str = 'BTCUSDT') -> Optional[float]:\n        \"\"\"Mevcut funding rate (Real API)\"\"\"\n        try:\n            url = f'{self.base_url}/fapi/v1/fundingRate'\n            response = requests.get(\n                url,\n                params={'symbol': symbol, 'limit': 1},\n                timeout=5\n            )\n            \n            if response.status_code == 200:\n                data = response.json()[0]\n                return float(data['fundingRate']) * 100\n        except Exception as e:\n            logger.error(f'Funding rate fetch hatasÄ±: {e}')\n        \n        return None\n    \n    def get_market_status(self) -> Dict[str, Any]:\n        \"\"\"Tam market status (Real Data)\"\"\"\n        btc_data = self.get_ticker_24h('BTCUSDT')\n        eth_data = self.get_ticker_24h('ETHUSDT')\n        btc_funding = self.get_funding_rate('BTCUSDT')\n        eth_funding = self.get_funding_rate('ETHUSDT')\n        \n        return {\n            'btc_price': btc_data['price'] if btc_data else 0,\n            'btc_change_24h': btc_data['change_24h'] if btc_data else 0,\n            'eth_price': eth_data['price'] if eth_data else 0,\n            'eth_change_24h': eth_data['change_24h'] if eth_data else 0,\n            'funding_rate': btc_funding or 0,\n            'volatility_status': 'YÃ¼ksek' if abs(btc_data['change_24h']) > 5 else 'Normal' if btc_data else 'N/A',\n            'liquidity_status': 'Yeterli' if (btc_data and btc_data['volume_24h'] > 1e9) else 'DÃ¼ÅŸÃ¼k' if btc_data else 'N/A',\n            'last_signal_time': datetime.now().strftime('%H:%M:%S'),\n            'active_trades': 0  # Will be updated from trading system\n        }\n\n# ============================================================================\n# 24/7 DAEMON CORE\n# ============================================================================\n\nclass DaemonCore:\n    \"\"\"24/7 Ã§alÄ±ÅŸan arka plan daemon sistemi\"\"\"\n    \n    def __init__(self):\n        self.telegram = TelegramAlertManager()\n        self.market_data = RealMarketData()\n        self.is_running = False\n        self.threads: List[threading.Thread] = []\n        self.start_time = datetime.now()\n        \n        logger.info('âœ… Daemon Core initialized')\n    \n    def start(self):\n        \"\"\"Daemon baÅŸlat (7/24)\"\"\"\n        if self.is_running:\n            logger.warning('âš ï¸ Daemon zaten Ã§alÄ±ÅŸÄ±yor')\n            return\n        \n        self.is_running = True\n        self.telegram.is_running = True\n        \n        logger.info('ğŸŸ¢ DAEMON STARTING - 7/24 MODE')\n        \n        # Hourly ping thread\n        hourly_thread = threading.Thread(\n            target=self._hourly_ping_loop,\n            daemon=True,\n            name='hourly_ping'\n        )\n        hourly_thread.start()\n        self.threads.append(hourly_thread)\n        \n        # Market monitor thread\n        market_thread = threading.Thread(\n            target=self._market_monitor_loop,\n            daemon=True,\n            name='market_monitor'\n        )\n        market_thread.start()\n        self.threads.append(market_thread)\n        \n        logger.info(f'âœ… Daemon baÅŸlatÄ±ldÄ±: {len(self.threads)} thread(s)')\n        \n        # Send startup alert\n        if self.telegram.enabled:\n            self.telegram.queue_alert(\n                'DEMIR AI Daemon baÅŸlatÄ±ldÄ±\\n7/24 canlÄ± piyasa takibi aktif',\n                AlertSeverity.SUCCESS\n            )\n    \n    def stop(self):\n        \"\"\"Daemon durdur\"\"\"\n        self.is_running = False\n        self.telegram.is_running = False\n        logger.info('ğŸ”´ Daemon durduruldu')\n    \n    def _hourly_ping_loop(self):\n        \"\"\"Her saat baÅŸÄ± status mesajÄ± gÃ¶nder\"\"\"\n        logger.info('ğŸ”„ Hourly Ping Loop baÅŸlatÄ±ldÄ±')\n        \n        while self.is_running:\n            try:\n                now = datetime.now()\n                \n                # Saat baÅŸÄ±na kontrol et (00, 01, 02 vb. dakika)\n                if now.minute == 0:\n                    # Market verilerini al\n                    market_status = self.market_data.get_market_status()\n                    \n                    # Mesaj oluÅŸtur\n                    message = self.telegram.get_hourly_ping_message(market_status)\n                    \n                    # Telegram'a gÃ¶nder\n                    self.telegram.queue_alert(message, AlertSeverity.SUCCESS)\n                    \n                    logger.info('ğŸ“¤ Saatlik bildirim gÃ¶nderildi')\n                    \n                    # 60 saniye bekle (tekrar gÃ¶ndermeyi Ã¶nle)\n                    time.sleep(60)\n                \n                time.sleep(10)  # 10 saniyede bir kontrol et\n                \n            except Exception as e:\n                logger.error(f'Hourly ping hatasÄ±: {e}')\n                time.sleep(60)\n    \n    def _market_monitor_loop(self):\n        \"\"\"SÃ¼rekli piyasayÄ± takip et ve sinyalleri izle\"\"\"\n        logger.info('ğŸ”„ Market Monitor Loop baÅŸlatÄ±ldÄ±')\n        \n        while self.is_running:\n            try:\n                # Market verilerini al\n                btc_ticker = self.market_data.get_ticker_24h('BTCUSDT')\n                eth_ticker = self.market_data.get_ticker_24h('ETHUSDT')\n                \n                # Extreme volatility alert\n                if btc_ticker and abs(btc_ticker['change_24h']) > 10:\n                    alert_msg = (\n                        f\"ğŸš¨ <b>YÃœKSEk VOLATÄ°LÄ°TE!</b>\\\\n\"\n                        f\"BTC 24h: {btc_ticker['change_24h']:+.2f}%\\\\n\"\n                        f\"Fiyat: ${btc_ticker['price']:,.2f}\"\n                    )\n                    self.telegram.queue_alert(alert_msg, AlertSeverity.CRITICAL)\n                \n                # Funding rate alert\n                funding = self.market_data.get_funding_rate('BTCUSDT')\n                if funding and abs(funding) > 0.1:\n                    alert_msg = (\n                        f\"âš ï¸ <b>YÃœKSEk FUNDING RATE</b>\\\\n\"\n                        f\"BTC Funding: {funding:+.3f}%\\\\n\"\n                        f\"Risk Seviyesi: YÃ¼ksek\"\n                    )\n                    self.telegram.queue_alert(alert_msg, AlertSeverity.WARNING)\n                \n                time.sleep(300)  # Her 5 dakikada kontrol et\n                \n            except Exception as e:\n                logger.error(f'Market monitor hatasÄ±: {e}')\n                time.sleep(60)\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Daemon durumunu al\"\"\"\n        uptime = datetime.now() - self.start_time\n        return {\n            'is_running': self.is_running,\n            'uptime_seconds': uptime.total_seconds(),\n            'uptime_hours': uptime.total_seconds() / 3600,\n            'telegram_enabled': self.telegram.enabled,\n            'threads_active': len([t for t in self.threads if t.is_alive()]),\n            'timestamp': datetime.now().isoformat()\n        }\n\n# ============================================================================\n# EXPORTS\n# ============================================================================\n\n__all__ = [\n    'DaemonCore',\n    'TelegramAlertManager',\n    'RealMarketData',\n    'AlertSeverity'\n]\n\n# ============================================================================\n# TESTING\n# ============================================================================\n\nif __name__ == '__main__':\n    logger.info('ğŸš€ DEMIR AI 7/24 Daemon Starting...')\n    \n    # Initialize daemon\n    daemon = DaemonCore()\n    \n    # Start daemon\n    daemon.start()\n    \n    # Test: Bir bildirim gÃ¶nder\n    if daemon.telegram.enabled:\n        daemon.telegram.queue_alert(\n            'âœ… Test MesajÄ±\\\\nDAEMON 7/24 Ã‡ALIÅIYOR',\n            AlertSeverity.SUCCESS\n        )\n    \n    # Keep running\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        daemon.stop()\n        logger.info('âœ… Test completed')
