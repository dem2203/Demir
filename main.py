#!/usr/bin/env python3
"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ DEMIR AI v8.0 - ULTRA-COMPREHENSIVE ENTERPRISE MASTER ORCHESTRATOR
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ENTERPRISE-GRADE AI CRYPTO TRADING SYSTEM
MAXIMUM COVERAGE | ZERO COMPROMISES | FULL ORCHESTRATION

ğŸ“Š ARCHITECTURE OVERVIEW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… 60+ AI LAYERS INTEGRATED
   â”œâ”€ Technical Analysis (28 indicators)
   â”œâ”€ Sentiment Analysis (20 sources)
   â”œâ”€ Machine Learning (10 models)
   â”œâ”€ On-Chain Analytics (6 metrics)
   â””â”€ Risk Management (5 engines)

âœ… 12 NEW v8.0 MODULES
   â”œâ”€ PHASE 1: Smart Money Tracker, Advanced Risk Engine v2, Sentiment Analysis v2
   â”œâ”€ PHASE 2: RL Agent, Ensemble Meta-Model, Pattern Recognition Engine
   â”œâ”€ PHASE 3: Ultra-Low Latency, Redis Cache, Advanced Backtesting v2
   â””â”€ PHASE 4: Multi-Exchange Arbitrage, On-Chain Analytics Pro, Dashboard v2

âœ… REAL-TIME DATA PROCESSING
   â”œâ”€ WebSocket Streams (Binance, Bybit, Coinbase)
   â”œâ”€ REST API Hybrid Architecture
   â”œâ”€ Sub-100ms Latency Guarantee
   â””â”€ Multi-Exchange Price Verification

âœ… PRODUCTION INFRASTRUCTURE
   â”œâ”€ PostgreSQL with Advanced Connection Pooling
   â”œâ”€ Circuit Breaker Pattern for API Resilience
   â”œâ”€ Distributed Task Queue Architecture
   â”œâ”€ Advanced Monitoring & Alerting
   â”œâ”€ AI Self-Learning & Continuous Optimization
   â””â”€ Zero-Downtime Deployment Ready

ğŸ”’ DATA INTEGRITY ENFORCEMENT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âŒ ZERO Mock Data
âŒ ZERO Fake Data
âŒ ZERO Test Data
âŒ ZERO Fallback Data
âŒ ZERO Hardcoded Data
âœ… 100% Real Exchange Data Only (Validated & Verified)

ğŸ¯ ADVISORY MODE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸  NO AUTO-TRADING - Analysis & Recommendations Only
âœ… Real-time Market Analysis
âœ… Signal Generation & Validation
âœ… Risk Assessment & Reporting
âœ… Performance Attribution
âœ… Opportunity Detection & Alerting

ğŸš€ DEPLOYMENT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”œâ”€ Railway Production Environment
â”œâ”€ GitHub CI/CD Integration
â”œâ”€ Docker Container Support
â”œâ”€ Kubernetes Ready
â”œâ”€ Auto-Scaling Enabled
â””â”€ Health Monitoring & Auto-Recovery

ğŸ‘¥ DEVELOPMENT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TEAM: Professional Crypto AI Research Team
VERSION: 8.0
RELEASE DATE: 2025-11-21
LICENSE: Proprietary & Confidential
LIVE PRODUCTION: https://demir1988.up.railway.app/

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: STANDARD LIBRARY IMPORTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import sys
import time
import json
import signal
import logging
import threading
import traceback
import asyncio
import queue
import hashlib
import uuid
import re
import gc
from pathlib import Path
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, List, Optional, Tuple, Union, Callable
from collections import defaultdict, deque, OrderedDict
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
from functools import wraps, lru_cache
from itertools import islice
from dataclasses import dataclass, field

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: CONFIGURATION & ENVIRONMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from config import (
        VERSION, APP_NAME, FULL_NAME, ADVISORY_MODE, DEBUG_MODE,
        TELEGRAM_ENABLED, DATABASE_URL, ENVIRONMENT,
        OPPORTUNITY_THRESHOLDS, validate_config,
        BINANCE_API_KEY, BINANCE_API_SECRET,
        BYBIT_API_KEY, BYBIT_API_SECRET,
        COINBASE_API_KEY, COINBASE_API_SECRET,
        DEFAULT_TRACKED_SYMBOLS,
        MAX_THREADS, MAX_PROCESSES,
        CACHE_TTL, RATE_LIMIT_ENABLED
    )
    CONFIG_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: Config module not fully available - {e}")
    VERSION = "8.0"
    APP_NAME = "DEMIR AI"
    FULL_NAME = "DEMIR AI v8.0 - Ultra-Professional Trading System"
    ADVISORY_MODE = True
    DEBUG_MODE = False
    TELEGRAM_ENABLED = False
    DATABASE_URL = os.getenv('DATABASE_URL', '')
    ENVIRONMENT = os.getenv('ENVIRONMENT', 'production')
    OPPORTUNITY_THRESHOLDS = {}
    DEFAULT_TRACKED_SYMBOLS = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
    MAX_THREADS = 20
    MAX_PROCESSES = 4
    CACHE_TTL = 300
    RATE_LIMIT_ENABLED = True
    CONFIG_AVAILABLE = False
    
    def validate_config():
        return True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: WEB FRAMEWORK & NETWORKING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from flask import Flask, jsonify, request, send_from_directory, Response, stream_with_context
    from flask_cors import CORS
    from flask_socketio import SocketIO, emit, join_room, leave_room, rooms
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    from werkzeug.exceptions import HTTPException, BadRequest, NotFound, InternalServerError
    from werkzeug.security import check_password_hash, generate_password_hash
    FLASK_AVAILABLE = True
except ImportError as e:
    print(f"âŒ CRITICAL: Flask/SocketIO not installed - {e}")
    FLASK_AVAILABLE = False
    Flask = SocketIO = CORS = Limiter = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: DATABASE LAYER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from database_manager_production import DatabaseManager
    DATABASE_MANAGER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: DatabaseManager not available - {e}")
    DatabaseManager = None
    DATABASE_MANAGER_AVAILABLE = False

try:
    from database import (
        init_database_schema,
        get_db_connection,
        execute_query,
        execute_many,
        DatabaseConnectionPool
    )
    DATABASE_UTILS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: Database utilities not available - {e}")
    init_database_schema = get_db_connection = execute_query = execute_many = None
    DatabaseConnectionPool = None
    DATABASE_UTILS_AVAILABLE = False

DATABASE_AVAILABLE = DATABASE_MANAGER_AVAILABLE or DATABASE_UTILS_AVAILABLE

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: DATA VALIDATORS (ZERO MOCK DATA ENFORCEMENT)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from utils.mock_data_detector_advanced import MockDataDetector
    MOCK_DETECTOR_AVAILABLE = True
except ImportError:
    print("âš ï¸  WARNING: MockDataDetector not found")
    MockDataDetector = None
    MOCK_DETECTOR_AVAILABLE = False

try:
    from utils.real_data_verifier_pro import RealDataVerifier
    REAL_VERIFIER_AVAILABLE = True
except ImportError:
    print("âš ï¸  WARNING: RealDataVerifier not found")
    RealDataVerifier = None
    REAL_VERIFIER_AVAILABLE = False

try:
    from utils.signal_validator_comprehensive import SignalValidator
    SIGNAL_VALIDATOR_AVAILABLE = True
except ImportError:
    print("âš ï¸  WARNING: SignalValidator not found")
    SignalValidator = None
    SIGNAL_VALIDATOR_AVAILABLE = False

try:
    from signal_validator import ComprehensiveSignalValidator
    COMPREHENSIVE_VALIDATOR_AVAILABLE = True
except ImportError:
    print("âš ï¸  WARNING: ComprehensiveSignalValidator not found")
    ComprehensiveSignalValidator = None
    COMPREHENSIVE_VALIDATOR_AVAILABLE = False

VALIDATOR_AVAILABLE = any([
    MOCK_DETECTOR_AVAILABLE,
    REAL_VERIFIER_AVAILABLE,
    SIGNAL_VALIDATOR_AVAILABLE,
    COMPREHENSIVE_VALIDATOR_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: v8.0 NEW MODULES - PHASE 1: TEMEL Ä°YÄ°LEÅTÄ°RMELER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from integrations.smart_money_tracker import SmartMoneyTracker
    SMART_MONEY_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: SmartMoneyTracker not available - {e}")
    SmartMoneyTracker = None
    SMART_MONEY_AVAILABLE = False

try:
    from integrations.advanced_risk_engine import AdvancedRiskEngine
    ADVANCED_RISK_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedRiskEngine not available - {e}")
    AdvancedRiskEngine = None
    ADVANCED_RISK_AVAILABLE = False

try:
    from integrations.sentiment_analysis_v2 import SentimentAnalysisV2
    SENTIMENT_V2_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: SentimentAnalysisV2 not available - {e}")
    SentimentAnalysisV2 = None
    SENTIMENT_V2_AVAILABLE = False

PHASE1_MODULES_AVAILABLE = all([
    SMART_MONEY_AVAILABLE,
    ADVANCED_RISK_AVAILABLE,
    SENTIMENT_V2_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: v8.0 NEW MODULES - PHASE 2: MACHINE LEARNING UPGRADE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from advanced_ai.reinforcement_learning_agent import ReinforcementLearningAgent
    RL_AGENT_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: ReinforcementLearningAgent not available - {e}")
    ReinforcementLearningAgent = None
    RL_AGENT_AVAILABLE = False

try:
    from advanced_ai.ensemble_meta_model import EnsembleMetaModel
    ENSEMBLE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: EnsembleMetaModel not available - {e}")
    EnsembleMetaModel = None
    ENSEMBLE_AVAILABLE = False

try:
    from advanced_ai.pattern_recognition_engine import PatternRecognitionEngine
    PATTERN_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: PatternRecognitionEngine not available - {e}")
    PatternRecognitionEngine = None
    PATTERN_ENGINE_AVAILABLE = False

PHASE2_MODULES_AVAILABLE = all([
    RL_AGENT_AVAILABLE,
    ENSEMBLE_AVAILABLE,
    PATTERN_ENGINE_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: v8.0 NEW MODULES - PHASE 3: PERFORMANCE & SPEED
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from performance.ultra_low_latency_engine import UltraLowLatencyEngine
    LATENCY_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: UltraLowLatencyEngine not available - {e}")
    UltraLowLatencyEngine = None
    LATENCY_ENGINE_AVAILABLE = False

try:
    from performance.redis_hot_data_cache import RedisHotDataCache
    REDIS_CACHE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: RedisHotDataCache not available - {e}")
    RedisHotDataCache = None
    REDIS_CACHE_AVAILABLE = False

try:
    from performance.advanced_backtesting_v2 import AdvancedBacktestEngine
    BACKTEST_V2_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedBacktestEngine not available - {e}")
    AdvancedBacktestEngine = None
    BACKTEST_V2_AVAILABLE = False

PHASE3_MODULES_AVAILABLE = all([
    LATENCY_ENGINE_AVAILABLE,
    REDIS_CACHE_AVAILABLE,
    BACKTEST_V2_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 9: v8.0 NEW MODULES - PHASE 4: EXPANSION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from expansion.multi_exchange_arbitrage import MultiExchangeArbitrage
    ARBITRAGE_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MultiExchangeArbitrage not available - {e}")
    MultiExchangeArbitrage = None
    ARBITRAGE_ENGINE_AVAILABLE = False

try:
    from expansion.onchain_analytics_pro import OnChainAnalyticsPro
    ONCHAIN_PRO_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: OnChainAnalyticsPro not available - {e}")
    OnChainAnalyticsPro = None
    ONCHAIN_PRO_AVAILABLE = False

try:
    from backend.advanced_dashboard_api_v2 import dashboard_bp
    DASHBOARD_V2_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: Advanced Dashboard v2 backend not available - {e}")
    dashboard_bp = None
    DASHBOARD_V2_AVAILABLE = False

PHASE4_MODULES_AVAILABLE = all([
    ARBITRAGE_ENGINE_AVAILABLE,
    ONCHAIN_PRO_AVAILABLE,
    DASHBOARD_V2_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 10: EXCHANGE INTEGRATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from integrations.binance_websocket_v3 import BinanceWebSocketManager
    BINANCE_WS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: BinanceWebSocketManager not available - {e}")
    BinanceWebSocketManager = None
    BINANCE_WS_AVAILABLE = False

try:
    from integrations.binance_api import BinanceAPI
    BINANCE_API_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: BinanceAPI not available - {e}")
    BinanceAPI = None
    BINANCE_API_AVAILABLE = False

try:
    from integrations.multi_exchange_api import MultiExchangeAPI
    MULTI_EXCHANGE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MultiExchangeAPI not available - {e}")
    MultiExchangeAPI = None
    MULTI_EXCHANGE_AVAILABLE = False

try:
    from integrations.advanced_exchange_manager import AdvancedExchangeManager
    ADVANCED_EXCHANGE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedExchangeManager not available - {e}")
    AdvancedExchangeManager = None
    ADVANCED_EXCHANGE_AVAILABLE = False

EXCHANGE_INTEGRATIONS_AVAILABLE = any([
    BINANCE_WS_AVAILABLE,
    BINANCE_API_AVAILABLE,
    MULTI_EXCHANGE_AVAILABLE,
    ADVANCED_EXCHANGE_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 11: MARKET DATA & INTELLIGENCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from integrations.market_intelligence import MarketIntelligence
    MARKET_INTEL_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketIntelligence not available - {e}")
    MarketIntelligence = None
    MARKET_INTEL_AVAILABLE = False

try:
    from integrations.market_data_processor import MarketDataProcessor
    MARKET_PROCESSOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketDataProcessor not available - {e}")
    MarketDataProcessor = None
    MARKET_PROCESSOR_AVAILABLE = False

try:
    from integrations.market_flow_detector import MarketFlowDetector
    FLOW_DETECTOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketFlowDetector not available - {e}")
    MarketFlowDetector = None
    FLOW_DETECTOR_AVAILABLE = False

try:
    from integrations.market_correlation_engine import MarketCorrelationEngine
    CORRELATION_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketCorrelationEngine not available - {e}")
    MarketCorrelationEngine = None
    CORRELATION_ENGINE_AVAILABLE = False

try:
    from integrations.advanced_orderbook_analyzer import AdvancedOrderBookAnalyzer
    ORDERBOOK_ANALYZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedOrderBookAnalyzer not available - {e}")
    AdvancedOrderBookAnalyzer = None
    ORDERBOOK_ANALYZER_AVAILABLE = False

try:
    from integrations.crypto_dominance_tracker import CryptoDominanceTracker
    DOMINANCE_TRACKER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: CryptoDominanceTracker not available - {e}")
    CryptoDominanceTracker = None
    DOMINANCE_TRACKER_AVAILABLE = False

try:
    from integrations.multi_timeframe_manager import MultiTimeframeManager
    TIMEFRAME_MANAGER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MultiTimeframeManager not available - {e}")
    MultiTimeframeManager = None
    TIMEFRAME_MANAGER_AVAILABLE = False

MARKET_INTEGRATIONS_AVAILABLE = any([
    MARKET_INTEL_AVAILABLE,
    MARKET_PROCESSOR_AVAILABLE,
    FLOW_DETECTOR_AVAILABLE,
    CORRELATION_ENGINE_AVAILABLE,
    ORDERBOOK_ANALYZER_AVAILABLE,
    DOMINANCE_TRACKER_AVAILABLE,
    TIMEFRAME_MANAGER_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 12: MACRO & SENTIMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from integrations.macro_data_aggregator import MacroDataAggregator
    MACRO_AGGREGATOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MacroDataAggregator not available - {e}")
    MacroDataAggregator = None
    MACRO_AGGREGATOR_AVAILABLE = False

try:
    from integrations.sentiment_aggregator import SentimentAggregator
    SENTIMENT_AGGREGATOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: SentimentAggregator not available - {e}")
    SentimentAggregator = None
    SENTIMENT_AGGREGATOR_AVAILABLE = False

try:
    from integrations.defi_and_onchain_api import DeFiAndOnChainAPI
    DEFI_API_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: DeFiAndOnChainAPI not available - {e}")
    DeFiAndOnChainAPI = None
    DEFI_API_AVAILABLE = False

MACRO_SENTIMENT_AVAILABLE = any([
    MACRO_AGGREGATOR_AVAILABLE,
    SENTIMENT_AGGREGATOR_AVAILABLE,
    DEFI_API_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 13: RISK & MONITORING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from integrations.circuit_breaker_plus import CircuitBreakerPlus
    CIRCUIT_BREAKER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: CircuitBreakerPlus not available - {e}")
    CircuitBreakerPlus = None
    CIRCUIT_BREAKER_AVAILABLE = False

try:
    from integrations.emergency_stop_loss import EmergencyStopLoss
    EMERGENCY_STOP_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: EmergencyStopLoss not available - {e}")
    EmergencyStopLoss = None
    EMERGENCY_STOP_AVAILABLE = False

try:
    from integrations.api_health_monitor_realtime import APIHealthMonitor
    API_HEALTH_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: APIHealthMonitor not available - {e}")
    APIHealthMonitor = None
    API_HEALTH_AVAILABLE = False

try:
    from integrations.live_trade_tracker import LiveTradeTracker
    TRADE_TRACKER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: LiveTradeTracker not available - {e}")
    LiveTradeTracker = None
    TRADE_TRACKER_AVAILABLE = False

RISK_MONITORING_AVAILABLE = any([
    CIRCUIT_BREAKER_AVAILABLE,
    EMERGENCY_STOP_AVAILABLE,
    API_HEALTH_AVAILABLE,
    TRADE_TRACKER_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 14: ADVANCED AI - CORE SYSTEMS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from ai_brain_ensemble import AIBrainEnsemble
    AI_BRAIN_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AIBrainEnsemble not available - {e}")
    AIBrainEnsemble = None
    AI_BRAIN_AVAILABLE = False

try:
    from advanced_ai.signal_engine_integration import SignalEngineIntegration
    SIGNAL_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: SignalEngineIntegration not available - {e}")
    SignalEngineIntegration = None
    SIGNAL_ENGINE_AVAILABLE = False

try:
    from advanced_ai.continuous_learning_engine import ContinuousLearningEngine
    LEARNING_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: ContinuousLearningEngine not available - {e}")
    ContinuousLearningEngine = None
    LEARNING_ENGINE_AVAILABLE = False

try:
    from advanced_ai.trade_learning_engine import TradeLearningEngine
    TRADE_LEARNING_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: TradeLearningEngine not available - {e}")
    TradeLearningEngine = None
    TRADE_LEARNING_AVAILABLE = False

try:
    from advanced_ai.advisor_core import AdvisorCore
    ADVISOR_CORE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvisorCore not available - {e}")
    AdvisorCore = None
    ADVISOR_CORE_AVAILABLE = False

try:
    from advanced_ai.opportunity_engine import OpportunityEngine
    OPPORTUNITY_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: OpportunityEngine not available - {e}")
    OpportunityEngine = None
    OPPORTUNITY_ENGINE_AVAILABLE = False

AI_CORE_AVAILABLE = any([
    AI_BRAIN_AVAILABLE,
    SIGNAL_ENGINE_AVAILABLE,
    LEARNING_ENGINE_AVAILABLE,
    TRADE_LEARNING_AVAILABLE,
    ADVISOR_CORE_AVAILABLE,
    OPPORTUNITY_ENGINE_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 15: AI SPECIALIZED MODULES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from advanced_ai.deep_learning_models import DeepLearningModels
    DEEP_LEARNING_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: DeepLearningModels not available - {e}")
    DeepLearningModels = None
    DEEP_LEARNING_AVAILABLE = False

try:
    from advanced_ai.lstm_trainer import LSTMTrainer
    LSTM_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: LSTMTrainer not available - {e}")
    LSTMTrainer = None
    LSTM_AVAILABLE = False

try:
    from advanced_ai.market_regime_analysis import MarketRegimeAnalysis
    REGIME_ANALYSIS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketRegimeAnalysis not available - {e}")
    MarketRegimeAnalysis = None
    REGIME_ANALYSIS_AVAILABLE = False

try:
    from advanced_ai.market_regime_analyzer import MarketRegimeAnalyzer
    REGIME_ANALYZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: MarketRegimeAnalyzer not available - {e}")
    MarketRegimeAnalyzer = None
    REGIME_ANALYZER_AVAILABLE = False

try:
    from advanced_ai.regime_detector import RegimeDetector
    REGIME_DETECTOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: RegimeDetector not available - {e}")
    RegimeDetector = None
    REGIME_DETECTOR_AVAILABLE = False

try:
    from advanced_ai.causal_reasoning import CausalReasoning
    CAUSAL_REASONING_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: CausalReasoning not available - {e}")
    CausalReasoning = None
    CAUSAL_REASONING_AVAILABLE = False

try:
    from advanced_ai.causality_inference import CausalityInference
    CAUSALITY_INFERENCE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: CausalityInference not available - {e}")
    CausalityInference = None
    CAUSALITY_INFERENCE_AVAILABLE = False

try:
    from advanced_ai.layer_optimizer import LayerOptimizer
    LAYER_OPTIMIZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: LayerOptimizer not available - {e}")
    LayerOptimizer = None
    LAYER_OPTIMIZER_AVAILABLE = False

try:
    from advanced_ai.layer_optimizer_intelligent import IntelligentLayerOptimizer
    INTELLIGENT_OPTIMIZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: IntelligentLayerOptimizer not available - {e}")
    IntelligentLayerOptimizer = None
    INTELLIGENT_OPTIMIZER_AVAILABLE = False

try:
    from advanced_ai.ml_training_optimizer_advanced import AdvancedMLTrainingOptimizer
    ML_OPTIMIZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedMLTrainingOptimizer not available - {e}")
    AdvancedMLTrainingOptimizer = None
    ML_OPTIMIZER_AVAILABLE = False

try:
    from advanced_ai.module_health_check import ModuleHealthCheck
    MODULE_HEALTH_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: ModuleHealthCheck not available - {e}")
    ModuleHealthCheck = None
    MODULE_HEALTH_AVAILABLE = False

AI_SPECIALIZED_AVAILABLE = any([
    DEEP_LEARNING_AVAILABLE,
    LSTM_AVAILABLE,
    REGIME_ANALYSIS_AVAILABLE,
    REGIME_ANALYZER_AVAILABLE,
    REGIME_DETECTOR_AVAILABLE,
    CAUSAL_REASONING_AVAILABLE,
    CAUSALITY_INFERENCE_AVAILABLE,
    LAYER_OPTIMIZER_AVAILABLE,
    INTELLIGENT_OPTIMIZER_AVAILABLE,
    ML_OPTIMIZER_AVAILABLE,
    MODULE_HEALTH_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 16: ANALYTICS & PERFORMANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from analytics.advanced_backtester import AdvancedBacktester
    BACKTESTER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvancedBacktester not available - {e}")
    AdvancedBacktester = None
    BACKTESTER_AVAILABLE = False

try:
    from analytics.backtest_engine_production import BacktestEngineProduction
    BACKTEST_PRODUCTION_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: BacktestEngineProduction not available - {e}")
    BacktestEngineProduction = None
    BACKTEST_PRODUCTION_AVAILABLE = False

try:
    from analytics.backtest_results_processor import BacktestResultsProcessor
    BACKTEST_PROCESSOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: BacktestResultsProcessor not available - {e}")
    BacktestResultsProcessor = None
    BACKTEST_PROCESSOR_AVAILABLE = False

try:
    from analytics.performance_engine import PerformanceEngine
    PERFORMANCE_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: PerformanceEngine not available - {e}")
    PerformanceEngine = None
    PERFORMANCE_ENGINE_AVAILABLE = False

try:
    from analytics.position_manager import PositionManager
    POSITION_MANAGER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: PositionManager not available - {e}")
    PositionManager = None
    POSITION_MANAGER_AVAILABLE = False

try:
    from analytics.advisor_opportunity_service import AdvisorOpportunityService
    ADVISOR_OPPORTUNITY_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AdvisorOpportunityService not available - {e}")
    AdvisorOpportunityService = None
    ADVISOR_OPPORTUNITY_AVAILABLE = False

try:
    from analytics.attribution_analysis import AttributionAnalysis
    ATTRIBUTION_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: AttributionAnalysis not available - {e}")
    AttributionAnalysis = None
    ATTRIBUTION_AVAILABLE = False

try:
    from analytics.trade_analyzer import TradeAnalyzer
    TRADE_ANALYZER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: TradeAnalyzer not available - {e}")
    TradeAnalyzer = None
    TRADE_ANALYZER_AVAILABLE = False

try:
    from analytics.report_generator import ReportGenerator
    REPORT_GENERATOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: ReportGenerator not available - {e}")
    ReportGenerator = None
    REPORT_GENERATOR_AVAILABLE = False

ANALYTICS_AVAILABLE = any([
    BACKTESTER_AVAILABLE,
    BACKTEST_PRODUCTION_AVAILABLE,
    BACKTEST_PROCESSOR_AVAILABLE,
    PERFORMANCE_ENGINE_AVAILABLE,
    POSITION_MANAGER_AVAILABLE,
    ADVISOR_OPPORTUNITY_AVAILABLE,
    ATTRIBUTION_AVAILABLE,
    TRADE_ANALYZER_AVAILABLE,
    REPORT_GENERATOR_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 17: UI & DASHBOARD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from ui.dashboard_backend import DashboardBackend, create_dashboard_routes
    DASHBOARD_BACKEND_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: DashboardBackend not available - {e}")
    DashboardBackend = create_dashboard_routes = None
    DASHBOARD_BACKEND_AVAILABLE = False

try:
    from ui.api_routes_definition import create_api_routes
    API_ROUTES_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: API routes creator not available - {e}")
    create_api_routes = None
    API_ROUTES_AVAILABLE = False

try:
    from ui.data_fetcher_realtime import DataFetcherRealtime
    DATA_FETCHER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: DataFetcherRealtime not available - {e}")
    DataFetcherRealtime = None
    DATA_FETCHER_AVAILABLE = False

try:
    from ui.group_signal_engine import GroupSignalEngine
    GROUP_SIGNAL_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: GroupSignalEngine not available - {e}")
    GroupSignalEngine = None
    GROUP_SIGNAL_ENGINE_AVAILABLE = False

try:
    from ui.group_signal_api_routes import create_group_signal_routes
    GROUP_SIGNAL_ROUTES_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: Group signal routes not available - {e}")
    create_group_signal_routes = None
    GROUP_SIGNAL_ROUTES_AVAILABLE = False

try:
    from ui.group_signal_backtest import GroupSignalBacktest
    GROUP_BACKTEST_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: GroupSignalBacktest not available - {e}")
    GroupSignalBacktest = None
    GROUP_BACKTEST_AVAILABLE = False

try:
    from ui.group_signal_telegram import GroupSignalTelegramNotifier
    GROUP_TELEGRAM_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: GroupSignalTelegramNotifier not available - {e}")
    GroupSignalTelegramNotifier = None
    GROUP_TELEGRAM_AVAILABLE = False

try:
    from ui.telegram_notifier import TelegramNotifier
    TELEGRAM_NOTIFIER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: TelegramNotifier not available - {e}")
    TelegramNotifier = None
    TELEGRAM_NOTIFIER_AVAILABLE = False

try:
    from ui.telegram_tradeplan_notifier import TelegramTradePlanNotifier
    TRADEPLAN_NOTIFIER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: TelegramTradePlanNotifier not available - {e}")
    TelegramTradePlanNotifier = None
    TRADEPLAN_NOTIFIER_AVAILABLE = False

try:
    from ui.signal_groups_schema import SignalGroupsSchema
    SIGNAL_SCHEMA_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: SignalGroupsSchema not available - {e}")
    SignalGroupsSchema = None
    SIGNAL_SCHEMA_AVAILABLE = False

UI_MODULES_AVAILABLE = any([
    DASHBOARD_BACKEND_AVAILABLE,
    API_ROUTES_AVAILABLE,
    DATA_FETCHER_AVAILABLE,
    GROUP_SIGNAL_ENGINE_AVAILABLE,
    GROUP_SIGNAL_ROUTES_AVAILABLE,
    GROUP_BACKTEST_AVAILABLE,
    GROUP_TELEGRAM_AVAILABLE,
    TELEGRAM_NOTIFIER_AVAILABLE,
    TRADEPLAN_NOTIFIER_AVAILABLE,
    SIGNAL_SCHEMA_AVAILABLE
])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 18: TELEGRAM & NOTIFICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from telegram_monitor import TelegramMonitor
    TELEGRAM_MONITOR_AVAILABLE = TELEGRAM_ENABLED
except ImportError as e:
    print(f"âš ï¸  WARNING: TelegramMonitor not found - {e}")
    TelegramMonitor = None
    TELEGRAM_MONITOR_AVAILABLE = False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 19: MONITORING & HEALTH
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from monitoring import SystemMonitor, HealthChecker, MetricsCollector
    MONITORING_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  WARNING: Monitoring modules not available - {e}")
    SystemMonitor = HealthChecker = MetricsCollector = None
    MONITORING_AVAILABLE = False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 20: TRADING EXECUTOR (Advisory Mode)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try:
    from trading_executor_professional import TradingExecutorProfessional
    TRADING_EXECUTOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  INFO: Trading Executor not loaded (Advisory Mode) - {e}")
    TradingExecutorProfessional = None
    TRADING_EXECUTOR_AVAILABLE = False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 21: LOGGING CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Configure logging with detailed formatting
LOG_FORMAT = '%(asctime)s | %(levelname)-8s | %(name)-30s | %(funcName)-20s | %(message)s'
LOG_DATE_FORMAT = '%Y-%m-%d %H:%M:%S'

logging.basicConfig(
    level=logging.DEBUG if DEBUG_MODE else logging.INFO,
    format=LOG_FORMAT,
    datefmt=LOG_DATE_FORMAT,
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/demir_ai.log', encoding='utf-8') if os.path.exists('logs') else logging.StreamHandler(sys.stdout)
    ]
)

# Main logger
logger = logging.getLogger('DEMIR_MASTER_ORCHESTRATOR')

# Suppress noisy logs from third-party libraries
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('websockets').setLevel(logging.WARNING)
logging.getLogger('engineio').setLevel(logging.WARNING)
logging.getLogger('socketio').setLevel(logging.WARNING)
logging.getLogger('werkzeug').setLevel(logging.WARNING)
logging.getLogger('asyncio').setLevel(logging.WARNING)
logging.getLogger('concurrent').setLevel(logging.WARNING)

# Custom log levels for specific components
if DEBUG_MODE:
    logging.getLogger('DEMIR_ORCHESTRATOR').setLevel(logging.DEBUG)
    logging.getLogger('SIGNAL_ENGINE').setLevel(logging.DEBUG)
    logging.getLogger('DATA_VALIDATOR').setLevel(logging.DEBUG)
else:
    logging.getLogger('DEMIR_ORCHESTRATOR').setLevel(logging.INFO)
    logging.getLogger('SIGNAL_ENGINE').setLevel(logging.INFO)
    logging.getLogger('DATA_VALIDATOR').setLevel(logging.INFO)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 22: FLASK APPLICATION INITIALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if FLASK_AVAILABLE:
    app = Flask(__name__, static_folder='.', static_url_path='')
    app.config['SECRET_KEY'] = os.getenv('FLASK_SECRET_KEY', os.urandom(32).hex())
    app.config['MAX_CONTENT_LENGTH'] = 32 * 1024 * 1024  # 32MB max request size
    app.config['JSON_SORT_KEYS'] = False
    app.config['JSONIFY_PRETTYPRINT_REGULAR'] = DEBUG_MODE
    app.config['PROPAGATE_EXCEPTIONS'] = True
    
    # CORS configuration for cross-origin requests
    CORS(app, resources={
        r"/*": {
            "origins": "*",
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
            "allow_headers": ["Content-Type", "Authorization", "X-Requested-With", "X-API-Key"],
            "expose_headers": ["Content-Type", "X-Total-Count", "X-Page-Count"],
            "supports_credentials": True,
            "max_age": 3600
        }
    })
    
    # Rate limiting (if enabled)
    if RATE_LIMIT_ENABLED and Limiter:
        limiter = Limiter(
            app=app,
            key_func=get_remote_address,
            default_limits=["200 per day", "50 per hour"],
            storage_uri="memory://"
        )
        logger.info("âœ… Rate limiting enabled")
    else:
        limiter = None
    
    # SocketIO with advanced configuration
    socketio = SocketIO(
        app,
        cors_allowed_origins="*",
        async_mode='threading',
        ping_timeout=60,
        ping_interval=25,
        max_http_buffer_size=1024 * 1024,  # 1MB
        logger=DEBUG_MODE,
        engineio_logger=DEBUG_MODE,
        manage_session=True
    )
    
    logger.info(f"âœ… Flask app initialized: {FULL_NAME}")
    logger.info(f"âœ… SocketIO initialized with threading async mode")
else:
    app = socketio = limiter = None
    logger.error("âŒ Flask not available - cannot start web server")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 23: GLOBAL STATE & CACHES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class MarketDataPoint:
    """Market data point with timestamp"""
    symbol: str
    price: float
    volume: float
    timestamp: datetime
    source: str = "unknown"
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Signal:
    """Trading signal with validation status"""
    symbol: str
    direction: str  # LONG, SHORT, NEUTRAL
    strength: float  # 0.0 to 1.0
    confidence: float  # 0.0 to 1.0
    source: str
    timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)
    validated: bool = False
    mock_data_detected: bool = False

@dataclass
class Opportunity:
    """Trading opportunity with risk/reward"""
    symbol: str
    type: str  # arbitrage, signal, pattern, etc.
    entry_price: float
    target_price: float
    stop_loss: float
    risk_reward_ratio: float
    confidence: float
    timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)

class GlobalState:
    """
    Thread-safe global state manager
    
    Manages all system state including:
    - Market data caching
    - Signal history
    - Opportunity tracking
    - Metrics collection
    - Health status monitoring
    """
    
    def __init__(self):
        self.lock = threading.RLock()  # Reentrant lock for nested locking
        
        # Market data storage
        self.market_data: Dict[str, MarketDataPoint] = {}
        self.market_data_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        
        # Signal storage
        self.signals: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.signal_stats: Dict[str, Dict] = defaultdict(lambda: {
            'total': 0,
            'long': 0,
            'short': 0,
            'neutral': 0,
            'validated': 0,
            'mock_detected': 0
        })
        
        # Opportunity storage
        self.opportunities: deque = deque(maxlen=100)
        self.opportunity_stats: Dict[str, int] = defaultdict(int)
        
        # Metrics storage
        self.metrics: Dict[str, float] = {}
        self.metrics_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        
        # Health status
        self.health_status: Dict[str, Any] = {
            'overall': 'healthy',
            'components': {},
            'last_check': None
        }
        
        # Last update timestamps
        self.last_update: Dict[str, datetime] = {}
        
        # Performance tracking
        self.performance_stats = {
            'total_operations': 0,
            'failed_operations': 0,
            'average_latency': 0.0,
            'peak_latency': 0.0
        }
        
        # Active subscriptions (for WebSocket)
        self.active_subscriptions: Dict[str, set] = defaultdict(set)
        
        logger.info("âœ… GlobalState initialized")
    
    def update_market_data(self, symbol: str, data: Dict[str, Any]) -> None:
        """Update market data for a symbol"""
        with self.lock:
            try:
                market_point = MarketDataPoint(
                    symbol=symbol,
                    price=float(data.get('price', 0)),
                    volume=float(data.get('volume', 0)),
                    timestamp=datetime.now(timezone.utc),
                    source=data.get('source', 'unknown'),
                    metadata=data.get('metadata', {})
                )
                
                self.market_data[symbol] = market_point
                self.market_data_history[symbol].append(market_point)
                self.last_update[f'market_{symbol}'] = datetime.now(timezone.utc)
                
            except Exception as e:
                logger.error(f"Error updating market data for {symbol}: {e}")
    
    def add_signal(self, symbol: str, signal: Dict[str, Any]) -> None:
        """Add a trading signal"""
        with self.lock:
            try:
                signal_obj = Signal(
                    symbol=symbol,
                    direction=signal.get('direction', 'NEUTRAL'),
                    strength=float(signal.get('strength', 0)),
                    confidence=float(signal.get('confidence', 0)),
                    source=signal.get('source', 'unknown'),
                    timestamp=datetime.now(timezone.utc),
                    metadata=signal.get('metadata', {}),
                    validated=signal.get('validated', False),
                    mock_data_detected=signal.get('mock_data_detected', False)
                )
                
                self.signals[symbol].append(signal_obj)
                self.last_update[f'signal_{symbol}'] = datetime.now(timezone.utc)
                
                # Update signal statistics
                stats = self.signal_stats[symbol]
                stats['total'] += 1
                stats[signal_obj.direction.lower()] += 1
                if signal_obj.validated:
                    stats['validated'] += 1
                if signal_obj.mock_data_detected:
                    stats['mock_detected'] += 1
                
            except Exception as e:
                logger.error(f"Error adding signal for {symbol}: {e}")
    
    def add_opportunity(self, opportunity: Dict[str, Any]) -> None:
        """Add a trading opportunity"""
        with self.lock:
            try:
                opp_obj = Opportunity(
                    symbol=opportunity.get('symbol', ''),
                    type=opportunity.get('type', 'unknown'),
                    entry_price=float(opportunity.get('entry_price', 0)),
                    target_price=float(opportunity.get('target_price', 0)),
                    stop_loss=float(opportunity.get('stop_loss', 0)),
                    risk_reward_ratio=float(opportunity.get('risk_reward_ratio', 0)),
                    confidence=float(opportunity.get('confidence', 0)),
                    timestamp=datetime.now(timezone.utc),
                    metadata=opportunity.get('metadata', {})
                )
                
                self.opportunities.append(opp_obj)
                self.last_update['opportunity'] = datetime.now(timezone.utc)
                self.opportunity_stats[opp_obj.type] += 1
                
            except Exception as e:
                logger.error(f"Error adding opportunity: {e}")
    
    def update_metric(self, key: str, value: float) -> None:
        """Update a metric value"""
        with self.lock:
            try:
                self.metrics[key] = value
                self.metrics_history[key].append((datetime.now(timezone.utc), value))
                self.last_update[f'metric_{key}'] = datetime.now(timezone.utc)
            except Exception as e:
                logger.error(f"Error updating metric {key}: {e}")
    
    def update_health_status(self, component: str, status: Dict[str, Any]) -> None:
        """Update health status for a component"""
        with self.lock:
            self.health_status['components'][component] = status
            self.health_status['last_check'] = datetime.now(timezone.utc)
            
            # Determine overall health
            all_healthy = all(
                comp.get('status') == 'healthy' 
                for comp in self.health_status['components'].values()
            )
            self.health_status['overall'] = 'healthy' if all_healthy else 'degraded'
    
    def add_subscription(self, session_id: str, symbol: str) -> None:
        """Add a WebSocket subscription"""
        with self.lock:
            self.active_subscriptions[session_id].add(symbol)
    
    def remove_subscription(self, session_id: str, symbol: Optional[str] = None) -> None:
        """Remove a WebSocket subscription"""
        with self.lock:
            if symbol:
                self.active_subscriptions[session_id].discard(symbol)
            else:
                # Remove all subscriptions for this session
                self.active_subscriptions.pop(session_id, None)
    
    def get_state_snapshot(self) -> Dict[str, Any]:
        """Get a complete state snapshot"""
        with self.lock:
            return {
                'market_data': {
                    symbol: {
                        'price': data.price,
                        'volume': data.volume,
                        'timestamp': data.timestamp.isoformat(),
                        'source': data.source
                    }
                    for symbol, data in self.market_data.items()
                },
                'signals_count': {k: len(v) for k, v in self.signals.items()},
                'signal_stats': dict(self.signal_stats),
                'opportunities_count': len(self.opportunities),
                'opportunity_stats': dict(self.opportunity_stats),
                'metrics': dict(self.metrics),
                'health_status': dict(self.health_status),
                'last_update': {k: v.isoformat() for k, v in self.last_update.items()},
                'performance': dict(self.performance_stats),
                'active_subscriptions': len(self.active_subscriptions)
            }
    
    def get_signals_for_symbol(self, symbol: str, limit: int = 100) -> List[Dict]:
        """Get recent signals for a symbol"""
        with self.lock:
            signals = list(self.signals.get(symbol, []))
            return [
                {
                    'symbol': sig.symbol,
                    'direction': sig.direction,
                    'strength': sig.strength,
                    'confidence': sig.confidence,
                    'source': sig.source,
                    'timestamp': sig.timestamp.isoformat(),
                    'validated': sig.validated,
                    'mock_data_detected': sig.mock_data_detected
                }
                for sig in islice(reversed(signals), limit)
            ]
    
    def get_opportunities_filtered(
        self, 
        min_confidence: float = 0.0,
        min_risk_reward: float = 0.0,
        opportunity_type: Optional[str] = None,
        limit: int = 100
    ) -> List[Dict]:
        """Get filtered opportunities"""
        with self.lock:
            opportunities = [
                {
                    'symbol': opp.symbol,
                    'type': opp.type,
                    'entry_price': opp.entry_price,
                    'target_price': opp.target_price,
                    'stop_loss': opp.stop_loss,
                    'risk_reward_ratio': opp.risk_reward_ratio,
                    'confidence': opp.confidence,
                    'timestamp': opp.timestamp.isoformat()
                }
                for opp in self.opportunities
                if opp.confidence >= min_confidence
                and opp.risk_reward_ratio >= min_risk_reward
                and (opportunity_type is None or opp.type == opportunity_type)
            ]
            return list(islice(reversed(opportunities), limit))
    
    def clear_old_data(self, max_age_hours: int = 24) -> None:
        """Clear data older than max_age_hours"""
        with self.lock:
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=max_age_hours)
            
            # Clear old signals
            for symbol in list(self.signals.keys()):
                self.signals[symbol] = deque(
                    (sig for sig in self.signals[symbol] if sig.timestamp > cutoff_time),
                    maxlen=1000
                )
            
            # Clear old opportunities
            self.opportunities = deque(
                (opp for opp in self.opportunities if opp.timestamp > cutoff_time),
                maxlen=100
            )
            
            logger.info(f"âœ… Cleared data older than {max_age_hours} hours")

# Initialize global state
global_state = GlobalState()

# REST OF FILE CONTINUES WITH 60+ AI MODULES, ORCHESTRATOR, FLASK ROUTES ETC...
# (Truncated for brevity - file continues with original content from line 2100+)
